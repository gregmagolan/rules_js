"Repository rules for importing packages from npm"

load("@aspect_bazel_lib//lib:repo_utils.bzl", "patch")
load(":npm_utils.bzl", "npm_utils")

def is_windows_os(rctx):
    os_name = rctx.os.name.lower()
    return os_name.find("windows") != -1

# TODO: handle npm packages with lifecycle hooks; src will be the output of the postinstall rule instead
_NODEJS_PACKAGE_TMPL = """def nodejs_package():
    _nodejs_package(
        name = "npm__{bazel_name}",
        src = "@{rctx_name}//:{dir}",
        package_name = "{package_name}",
        package_version = "{package_version}",
        visibility = ["//visibility:public"],{maybe_transitive}{maybe_deps}
    )
"""

_NODEJS_PACKAGE_EXPERIMENTAL_REF_DEPS_TMPL = _NODEJS_PACKAGE_TMPL + """    _nodejs_package(
        name = "npm__{bazel_name}__ref",
        package_name = "{package_name}",
        package_version = "{package_version}",{maybe_transitive}
    )
"""

def _impl(rctx):
    tarball = "package.tgz"
    rctx.download(
        output = tarball,
        url = "https://registry.npmjs.org/{0}/-/{1}-{2}.tgz".format(
            rctx.attr.package_name,
            # scoped packages contain a slash in the name, which doesn't appear in the later part of the URL
            rctx.attr.package_name.split("/")[-1],
            rctx.attr.package_version,
        ),
        integrity = rctx.attr.integrity,
    )

    dirname = "package"
    mkdir_args = ["mkdir", "-p", dirname] if not is_windows_os(rctx) else ["cmd", "/c", "if not exist {dir} (mkdir {dir})".format(dir = dirname.replace("/", "\\"))]
    result = rctx.execute(mkdir_args)
    if result.return_code:
        msg = "mkdir %s failed: \nSTDOUT:\n%s\nSTDERR:\n%s" % (dirname, result.stdout, result.stderr)
        fail(msg)

    # npm packages are always published with one top-level directory inside the tarball, tho the name is not predictable
    # so we use tar here which takes a --strip-components N argument instead of rctx.download_and_extract
    untar_args = ["tar", "-xf", tarball, "--strip-components", str(1), "-C", dirname]
    result = rctx.execute(untar_args)
    if result.return_code:
        msg = "tar %s failed: \nSTDOUT:\n%s\nSTDERR:\n%s" % (dirname, result.stdout, result.stderr)
        fail(msg)

    rctx.file("BUILD.bazel", "exports_files([\"{dir}\"])".format(dir = dirname))

    deps = []
    for dep in rctx.attr.deps:
        dep_split = dep.split("@")
        dep_name = "@".join(dep_split[:-1])
        dep_version = dep_split[-1]
        dep_target = "npm__{bazel_name}__ref" if rctx.attr.experimental_reference_deps else "npm__{bazel_name}"
        deps.append(dep_target.format(
            bazel_name = npm_utils.bazel_name(dep_name, dep_version)
        ))

    nodejs_package_tmpl = _NODEJS_PACKAGE_EXPERIMENTAL_REF_DEPS_TMPL if rctx.attr.experimental_reference_deps else _NODEJS_PACKAGE_TMPL
    nodejs_package_bzl = [nodejs_package_tmpl.format(
        dir = dirname,
        package_name = rctx.attr.package_name,
        package_version = rctx.attr.package_version,
        rctx_name = rctx.name,
        bazel_name = npm_utils.bazel_name(rctx.attr.package_name, rctx.attr.package_version),
        maybe_transitive = """
        transitive = True,""" if rctx.attr.transitive else "",
        maybe_deps = ("""
        deps = %s,""" % deps) if len(deps) > 0 else "",
    )]

    bzl_header = [
        "# @generated by npm_import.bzl",
        """load("@aspect_rules_js//js:nodejs_package.bzl", _nodejs_package = "nodejs_package")""",
        "",
    ]
    rctx.file("nodejs_package.bzl", "\n".join(bzl_header + nodejs_package_bzl))

    # Apply patches to the extracted package
    patch(rctx, patch_args = rctx.attr.patch_args, patch_directory = dirname)

_ATTRS = {
    "deps": attr.string_list(),
    "integrity": attr.string(),
    "package_name": attr.string(mandatory = True),
    "package_version": attr.string(mandatory = True),
    "patch_args": attr.string_list(),
    "patches": attr.label_list(),
    "transitive": attr.bool(),
    # Experimental reference deps allow dep to support circular deps between npm packages.
    # This feature depends on dangling symlinks, however, which is still experimental in bazel,
    # has issues with "host" and "exec" configurations, and does not yet work with remote exection.
    "experimental_reference_deps": attr.bool(), 
}

npm_import = struct(
    implementation = _impl,
    attrs = _ATTRS,
)
